OOP ADALAH :

- Object Oriented Programming adalah sudut pandang bahasa pemrograman yang berkonsep “objek”
- Ada banyak sudut pandang bahasa pemrograman, namun OOP adalah yang sangat populer saat ini.
- Ada beberapa istilah yang perlu dimengerti dalam OOP, yaitu: Object dan Class

    Apa Itu Object:
    - Object adalah data yang berisi properties (fields atau attributes) dan functions (methods atau behavior)
    - Semua data di Kotlin adalah object, dari mulai Number, Boolean, Character, String dan yang lainnya

    Apa itu Class :
    - Class adalah blueprint, prototype atau cetakan untuk membuat Object
    - Class berisikan deklarasi semua properties dan functions yang dimiliki oleh Object
    - Setiap Object selalu dibuat dari Class
    - Dan sebuah Class bisa membuat Object tanpa batas

CLASS :

Membuat Class :
- Untuk membuat class di Kotlin, kita bisa menggunakan kata kunci class
- Membuat class di Kotlin tidak ada aturan harus sama dengan nama file seperti di Java
- Namun agar kodenya rapih dan mudah untuk dimengerti, disarankan untuk membuat nama class dan nama file sama. Misal class Person di file Person.kt

OBJECT :

- Membuat Object di Kotlin sangat mudah, mirip seperti memanggil function, dengan menggunakan nama class
- Di Kotlin, tidak butuh kata kunci khusus untuk membuat Object, misal jika di Java kita butuh menggunakan kata kunci new untuk membuat Object

PROPERTIES :

- Properties / Fields / Attributes adalah data yang bisa kita sisipkan di dalam Object
- Namun sebelum kita bisa memasukkan data di Properties, kita harus mendeklarasikan data apa aja yang dimiliki object tersebut di dalam deklarasi class-nya
- Membuat Properties sama seperti membuat variable, bisa mutable atau immutable

    Manipulasi Propersties :
    - Properties yang ada di object, bisa kita manipulasi. Tergantung mutable atau immutable.
    - Jika mutable, berarti kita bisa mengubah data properties nya, namun jika immutable, kita hanya bisa mengambil data properties nya saja
    - Untuk memanipulasi data properties, sama seperti cara pada variable
    - Untuk mengakses properties, kita butuh kata kunci . (titik) setelah nama object dan diikuti nama properties nya

Constructor:

- Saat kita membuat Object, maka kita seperti memanggil sebuah function
- Di dalam class Kotlin, kita bisa membuat Constructors, Constructors mirip seperti function yang akan dipanggil saat pertama kali Object dibuat.
- Mirip seperti di Function, kita bisa memberi parameter pada Constructors

INITIALIZER BLOCK :

- Initializer Block adalah blok kode yang akan dieksekusi ketika constructor dipanggil
- Kita bisa memasukkan kode program di dalam initializer block

SECONDARY CONSTRUCTOR :

- Kotlin mendukung pembuatan constructor lebih dari satu
- Constructor yang utama yang terdapat di Class, disebut primary constructor, constructor tambahan yang bisa kita buat lagi adalah secondary constructor
- Saat membuat constructor, kita wajib memanggil primary constructor jika ada primary constructor

PROPERTIES CONSTRUCTOR :

- Kotlin mendukung deklarasi properties langsung di primary constructor
- Ini sangat berguna untuk mempersingkat saat kita ingin membuat properties, dan mengisi datanya lewat constructor

FUNCTION :

- Selain Parameters / Fields / Attributes, di dalam Class, kita juga bisa mendeklarasikan Function
- Function yang kita deklarasikan di dalam Class, secara otomatis menjadi behaviour si object yang dibuat dari class tersebut

FUNCTION OVERLOADING :

- Function Overloading adalah kemampuan membuat function dengan nama yang sama di dalam class
- Untuk membuat function dengan nama yang sama, kita wajib menggunakan parameter yang berbeda, bisa tipe parameter yang berbeda, atau jumlah parameter yang berbeda

THIS KEYWORD :

- this adalah keyword yang bisa digunakan untuk mereferensikan object saat ini
- this hanya bisa digunakan di dalam class itu sendiri
- Biasanya, this digunakan untuk mengakses properties yang tertutup oleh parameter dengan nama yang sama

INHERITANCE :

- Inheritance atau pewarisan adalah kemampuan untuk menurunkan sebuah class ke class lain
- Dalam artian, kita bisa membuat class Parent dan class Child
- Di Kotlin, tiap class Child, hanya bisa punya satu class Parent, namun satu class Parent bisa punya banyak class Child
- Secara standar, di class yang dibuat di Kotlin adalah final (tidak bisa diwariskan), agar bisa diwariskan, kita harus menggunakan kata kunci open

FUNCTION OVERRIDING :

- Function Overriding adalah kemampuan membuat ulang function yang sudah ada di class Parent
- Secara standar, function di class adalah final, tidak bisa dibuat ulang di class Child
- Agar function bisa dibuat ulang di class Child, kita harus menggunakan kata kunci open

    Final Overriding Function :
    - Saat kita membuat ulang function di class Child, secara standar, function tersebut bersifat open, yang artinya bisa dibuat ulang di class Child dibawahnya lagi
    - Jika ingin membuat override function tidak bisa dibuat ulang oleh class Child dibawahnya lagi, kita harus menggunakan kata kunci final

PROPERTIES OVERRIDING :

- Selain membuat ulang function di class Child, di Kotlin juga kita bisa membuat ulang properties
- Secara standar, properties di class bersifat final, tidak bisa di buat ulang di class Child nya, agar bisa dibuat ulang, kita harus menggunakan kata kunci open

SUPER KEYWORD :

- Kadang kita ingin mengakses function atau properties milik class Parent yang sudah dibuat ulang oleh class Child
- Untuk mengakses function  atau properties milik class Parent, kita bisa menggunakan kata kunci super

SUPER CONSTRUCTOR :

- Kata kunci super tidak hanya bisa digunakan untuk mengakses function atau properties di class Parent
- Kata kunci super juga bisa digunakan untuk mengakses constructor class Parent
- Mengakses constructor class Parent hanya bisa dilakukan di dalam constructor class Child

ANY CLASS :

- Di Kotlin, semua class yang kita buat tanpa class Parent, sebenarnya secara otomatis dia akan menjadi class child dari class Any
- Any adalah superclass untuk semua class yang kita buat di Kotlin

TYPE CHECK & CAST :

- Dalam Object Oriented Programming, kita akan bertemu dengan banyak sekali tipe data (class) dan pewarisan (inheritance)
- Kadang kita butuh melakukan pengecekan tipe data, atau bahkan melakukan konversi data

    is & ! is OPERATOR :
    - is digunakan untuk melakukan pengecekan apakah sebuah data merupakan tipe data tertentu
    - !is digunakan untuk melakukan pengecekan apakah sebuah data bukan merupakan tipe data tertentu

    SMART CASTS :
    - Kotlin memiliki mekanisme konversi data secara otomatis setelah kita melakukan pengecekan menggunakan is
    - Setelah kita melakukan pengecekan menggunakan is, maka secara otomatis tipe data yang kita cek akan berubah menjadi tipe data yang kita check

    CASTS DI WHEN EXPRESSION :
    - Selain menggunakan If untuk melakukan pengecekan tipe data dan konversi tipe data
    - Kita juga bisa menggunakan when expression
    - Penggunaan when expression akan lebih sederhana dibanding if expression dalam melakukan pengecekan dan konversi tipe data

    UNSAFE CASTS :
    - Kotlin juga mendukung konversi tipe data secara paksa menggunakan kata kunci as
    - Namun konversi menggunakan as sangat tidak aman jika ternyata tipe datanya tidak sesuai

    SAFE NULLABLE CASTS :
    - Penggunaan as sangat tidak aman, namun kadang bisa menjadikannya aman, dengan menggunakan kata kunci as?
    - Dengan menggunakan kata kunci as? secara otomatis jika gagal melakukan konversi, akan diubah menjadi null

FUNCTION TOSTRING() :

- toString() adalah function yang digunakan untuk memberitahu representasi String dari object
- Saat kita melakukan println object, sebenarnya function toString() akan dipanggil
- Standarnya, function toString() akan mengembalikan referensi kode unik dari object
- Kita bisa meng-override function toString() jika ingin mengubah representasi dari String pada object kita

FUNCTION EQUALS :

- Di Kotlin, semua objek bisa dibandingkan menggunakan operasi == atau !=
- Saat kita membandingkan objek menggunakan operasi == atau !=, sebenarnya Kotlin akan menggunakan function equals milik class Any
- Untuk mengubah cara membandingkannya, kita bisa meng-override function equals milik class Any

FUNCTION HASHCODE :

- hashCode adalah function yang digunakan sebagai representasi angka unit untuk objek yang kita buat
- Function hashCode sangat berguna saat kita ingin mengkonversi objek kita menjadi angka
- Salah satu penggunaan hashCode yang banyak dilakukan adalah di struktur data, misal untuk memastikan tidak ada data duplicate, agar lebih mudah, di cek nilai hashCode nya, jika hashCode sama, maka dianggap objectnya sama

CLASS ABSTRACT :

- Saat kita membuat class, kita bisa menjadikan sebuah class sebagai abstract
- Abstract class artinya, class tersebut tidak bisa dibuat sebagai object, hanya bisa diturunkan

ABSTRACT PROPERTIES & FUNCTION :

- Saat kita membuat class yang abstract, kita bisa membuat properties abstract dan function abstract di dalam class tersebut
- Properties dan function yang bersifat abstract, artinya wajib dibuat ulang di class Child nya

GETTER & SETTER :

- Di bahasa pemrograman Java, ada sebuah konsep yang bernama Getter dan Setter saat membuat properties
- Getter adalah function yang dibuat untuk mengambil data properties
- Setter ada function untuk mengubah data propertie
- Di kotlin, kita tidak perlu manual untuk membuat function Getter dan Setter nya, karena sudah difasilitasi sehingga lebih mudah

        Optional Getter & Setter :
        - Getter dan Setter tidak wajib dideklarasikan semua di Kotlin
        - Kita bisa hanya mendeklarasikan hanya Getter atau hanya Setter

LATE-INITIALIZED PROPERTIES :

- Standarnya, properties di Kotlin wajib di inisialisasi di awal saat deklarasi properties tersebut
- Namun di Kotlin kita juga bisa menunda inisialisasi data para properties
- Dengan menggunakan kata kunci lateinit, kita bisa membuat properties tanpa harus langsung mengisi datanya
- Kata kunci lateinit hanya bisa digunakan di var, tidak bisa digunakan di val

INTERFACE :

- Di kotlin, deklarasi type tidak hanya dalam bentuk class, ada juga interface
- Interface adalah blueprint, prototype atau cetakan di Kotlin
- Berbeda dengan Class, Interface tidak bisa langsung dibuat sebagai Object
- Interface hanya bisa diturunkan, dan biasanya Interface digunakan sebagai kontrak untuk class - class turunannya
- Secara standar, semua properties dan function di Interface adalah abstract

        Concrete Function di Interface :
        - Function di Interface memiliki pengecualian, tidak harus abstract
        - Kita bisa membuat concrete function di Interface, artinya function tersebut tidak wajib untuk dibuat ulang di child Class nya

        Multiple Inheritance dengan Interface :
        - Inheritance di Class hanya boleh memiliki satu class Parent
        - Di Interface, sebuah class Child bisa memiliki banyak interface Parent

        Inheritance antar Interface :
        - Tidak hanya Class yang punya kemampuan Inheritance
        - Interface juga bisa melakukan Inheritance dengan Interface lain
        - Namun Interface tidak bisa melakukan Inheritance dengan Class

VISIBILITY MODIFIERS :

- Class, Interface, Constructor, Function, dan Properties (termasuk Getter dan Setter) bisa memiliki Visibility Modifiers di Kotlin
- Ada 4 visibility modifiers di kotlin, yaitu: public, private, protected, internal
- Secara standar visibility modifiers di kotlin adalah public

        Perbedaan tiap Visibility Modifier :
         Visibility Modifiers | Keterangan
        - public
          Jika tidak menyebutkan, maka secara otomatis visibility modifiers nya adalah public, yang artinya bisa diakses dari manapun
        - private
          Artinya hanya bisa diakses di tempat deklarasinya
        - protected
          Artinya hanya bisa diakses di tempat deklarasi, dan juga turunannya
        - internal
          Artinya hanya bisa diakses di module/project yang sama.

Extension Function :

- Pada materi Kotlin Dasar kita sudah membahas tentang Extension Function, yaitu menambahkan function pada tipe data yang sudah ada

        Extension Bukanlah Function di Class :
        - Perlu diperhatikan, bahwa saat membuat extension function, kita tidak memodifikasi class aslinya
        - Extension function hanyalah sebuah function bantuan yang artinya, kita tidak bisa mengakses data private atau protected dari class tersebut

        Nullable Extension Function :
        - Secara standar, extension function hanya bisa untuk data yang tidak null
        - Jika kita ingin membuat extension function yang bisa digunakan untuk data yang bisa null, kita perlu menggunakan kata kunci ? (tanda tanya)

Extension Properties :

- Selain function, kita juga bisa membuat extension untuk properties di Kotlin
- Untuk membuat extension properties, kita bisa membuat properties dengan Getter atau Setter

DATA CLASS :

- Kadang kita sering membuat class yang hanya digunakan sebagai representasi dari data
- Data Class cocok digunakan dalam hal ini
- Data Class merupakan class yang secara otomatis akan membuatkan function equals, hashCode, toString dan copy dari semua properties yang terdapat di primary constructors yang dimiliki oleh data class

        Copy Data Class :
        - Data class memiliki function copy yang bisa digunakan untuk menduplikasi object.
        - Bahkan metode copy yang terdapat di data class bisa digunakan untuk menduplikasi sekaligus mengubah properties nya

Sealed Class :

- Sealed class merupakan jenis class yang didesain untuk inheritance
- Sealed class tidak bisa diinstansiasi menjadi object, dan secara standar sealed class merupakan abstract class
- Sealed class sangat cocok digunakan sebagai class Parent

        Sealed Class di When Expression :
        - Sealed class sangat berguna saat kita menggunakan when expression
        - Dengan menggunakan sealed class, kita bisa membatasi hanya class turunannya yang perlu di check

INNER CLASS :

- Di Kotlin, kita bisa membuat class (Inner) di dalam class (Outer)
- Namun walaupun class Inner tersebut berada di dalam class Outer, namun class Inner tidak bisa mengakses data yang ada di dalam class Outer
- Agar class Inner bisa mengakses data yang ada di dalam class Outer, kita bisa menggunakan kata kunci inner

ANONYMOUS CLASS :

- Saat kita ingin membuat object, maka kita diwajibkan untuk menggunakan deklarasi class yang  lengkap
- Namun, Kotlin mendukung pembuatan object dari class yang bahkan belum lengkap
- Bahkan, di Kotlin, kisa bisa membuat object dari interface
- Kemampuan ini dinamakan anonymous class
- Untuk membuat anonymous class, kita bisa menggunakan kata kunci object diikuti dengan deklarasi class Child seperti pada pewarisan

ENUM CLASS :

- Enum class merupakan representasi dari class yang sudah tetap nilainya
- Biasanya enum class digunakan untuk jenis data yang sudah baku, seperti jenis kelamin, arah mata angin dan sejenisnya
- Untuk membuat enum class, kita bisa menggunakan kata kunci enum sebelum deklarasi class nya
- Kita tidak bisa membuat object dari class enum, namun kita bisa mendeklarasikan langsung object yang tersedia untuk enum class tersebut


        Properties Function di Enum Class :
        - Enum class adalah class seperti biasa pada umumnya
        - Enum class bisa memiliki properties ataupun function
        - Namun jika properties nya di set menggunakan constructors, maka saat pembuatan object enum, wajib diisi, dan jika terdapat abstract function, wajib di override pada saat pembuatan object enum

SINGLETON OBJECT :

- Salah satu konsep Design Pattern yang sangat populer adalah singleton object
- Singleton object adalah object yang hanya dibuat satu kali
- Di Kotlin, membuat object singleton sangat mudah, hanya dengan menggunakan kata kunci object
- Cara membuat singleton object di Kotlin sama seperti membuat class
- Singleton object mirip dengan class, bisa extends class ataupun interface
- Namun singleton object tidak memiliki constructors

        Inner Object :
        - Di Kotlin, singleton object bisa dibuat di dalam sebuah class
        - Namun berbeda dengan inner class, singleton object tidak bisa mengakses properties atau function yang ada di outer class nya

COMPANION OBJECT :

- Companion object adalah kemampuan membuat inner object di dalam class, tanpa harus menggunakan nama object
- Companion object secara otomatis akan menggunakan nama Companion, atau bisa langsung diakses lewat nama class nya

TYPE ALIAS :

- Kotlin mendukung Type Alias
- Type Alias adalah membuat nama berbeda dari tipe data yang telah ada
- Biasanya ini digunakan ketika ada tipe data dengan nama yang sama, atau untuk mempersingkat tipe data sehingga kita tidak perlu menulisnya terlalu panjang

        Type Alias untuk Function :
        - Type Alias tidak hanya bisa digunakan untuk class saja, namun bisa untuk function
        - Dengan menggunakan Type Alias untuk function, kita akan lebih mudah saat menggunakan function sebagai parameter, karena lebih sederhana

INLINE CLASS :

- Kadang kita hanya membuat class dengan satu properties
- Terlalu banyak class akan ada konsekuensinya, yaitu memakan konsumsi memory yang lebih banyak ketika program kita berjalan
- Kotlin memiliki kemampuan untuk mengubah class menjadi inline dengan menggunakan kata kunci inline

DELEGATION :

- Salah satu design pattern lain yang populer adalah Delegation
- Delegation sederhananya adalah meneruskan properties atau function ke object yang lain
- Kotlin mendukung delegation tanpa harus membuat kode secara manual

        Override Delegation :
        - Dalam delegation, properties dan function secara otomatis akan didelegasikan ke object yang dipilih
        - Namun kita tetap bisa meng-override properties dan function jika kita mau

LAZY PROPERTIES :

- Selain delegating di class, Kotlin mendukung delegating di properties. Namun materi ini tidak akan dibahas disini, karena butuh mengerti dahulu tentang Generic Programming. Materi Delagating di Properties akan dibahas di series Kotlin Generic
- Salah satu implementasi delegating properties yang sudah disediakan oleh Kotlin adalah, lazy properties
- Lazy adalah standar library yang telah disediakan agar properties baru diinisialisasi ketika properties itu diakses


OBSERVABLE PROPERTIES :

- Salah satu standar library yang disediakan oleh Kotlin untuk delegating di properties adalah observable properties
- Dengan observable properties, kita bisa tahu properties, value sebelum dan value setelah ketika diubah

DESTRUCTURING DECLARATIONS :

- Destructuring declaration adalah membuat multiple variables dari sebuah object
- Destructuring tidak bisa dilakukan untuk semua object,  hanya objek yang memiliki function componentX() yang bisa dilakukan destructuring
- Saat kita membuat data class, secara otomatis akan dibuatkan function componentX() sesuai dengan jumlah parameter nya

        Desructuring Function :
        - Destructuring declarations juga bisa dilakukan ketika memanggil function
        - Dengan ini, seakan-akan kita bisa mengembalikan multiple return value pada function

        Underscore Untuk Variable Tidak Di Gunakan :
        - Kadang kita hanya ingin melakukan destructuring pada beberapa variable, dan menghiraukan variable lainnya
        - Untuk menghiraukan suatu variable, kita bisa menggunakan kata kunci  _ (underscore)

        Destructuring Lambda Parameter :
        - Destructuring juga bisa dilakukan di lambda parameter
        - Hal ini bisa mempermudah kita saat ingin mengakses data yang ada di parameter

OPERATOR OVERLOADING :

- Kotlin mendukung operator overloading, artinya kita bisa membuat function dari operator-operator seperti operator matematika, dan lain-lain
- Kemampuan ini membuat kita bisa melakukan operasi apapun di object seperti layaknya tipe data Integer
- Ada banyak sekali operator yang bisa di override di Kotlin

(PR)
===============================================


        Membuat Operator Overloading :
        - Untuk membuat operator overloading, kita bisa menggunakan kata kunci operator sebelum deklarasi function nya

NULL SAFETY :

- Jika teman-teman sebelumnya pernah belajar bahasa pemrograman Java, di Java kita sering mengenal error bernama NullPointerException. Error ini terjadi ketika kita mengakses properties atau functions di null object
- Di Kotlin, hal ini sangat jarang terjadi, karena sejak awal di Kotlin tidak direkomendasikan untuk menggunakan nullable type.
- Walaupun akan menggunakan nullable type, di Kotlin kita memberitahu secara eksplisit menggunakan karakter ? (tanda tanya)
- Kali ini kita akan bahas cara-cara agar terhindar dari error null di Kotlin sehingga tidak sering kejadian seperti di Java

        !!Operator :
        - Jika kita sangat mencintai NullPointerException :D
        - Dan kita benar-benar yakin bahwa variabel tersebut tidak null
        - Maka kita bisa menggunakan kata kunci !! untuk mengkonversi dari data yang nullable menjadi data tidak nullable
        - Tapi ingat, konsekuensinya, jika sampai ternyata datanya null, maka akan terjadi error

EXCEPTION :

- Saat membuat program, kita pasti akan selalu berhadapan dengan error
- Banyak sekali jenis error, baik itu error yang sudah diduga, seperti validation error, atau error yang tidak terduga, seperti ada jaringan error, koneksi ke database error, dan lain-lain
- Error di Kotlin direpresentasikan dengan Exception, dimana semua tipe data error pasti akan selalu class turunan dari Throwable
- Untuk membuat error di Kotlin sangatlah mudah, kita bisa menggunakan kata kunci throw, diikuti dengan object error nya

        Try Catch :
        - Jika dalam program Kotlin kita terjadi exception, maka secara otomatis program kita akan terhenti
        - Kadang kita tidak ingin sampai kejadian seperti itu
        - Di Kotlin, kita bisa menangkap exception, lalu melakukan sesuatu jika terjadi error
        - Try Catch di Kotlin digunakan untuk mencoba melakukan sesuatu, jika terjadi error maka akan ditangkap dan kita bisa memberi reaksi sesuai dengan yang kita mau

        Multiple Catch :
        - Saat kita mengeksekusi sebuah kode program di blok Try, bisa dimungkinan tidak hanya terjadi satu jenis exception, bisa saja terjadi beberapa jenis exception
        - Di Kotlin, kita bisa menggunakan multiple block Catch, untuk menangkap jenis exception yang berbeda

        Finally :
        - Finally adalah block kode yang bisa ditambahkan di Try Catch
        - Block finally akan selalu dieksekusi setelah kode program Try Catch di eksekusi, baik itu sukses ataupun gagal
        - Ini cocok untuk menempatkan kode yang memang harus dilakukan tidak peduli baik itu kodenya sukses atau gagal

ANNOTATION :

- Annotation adalah menambahkan metadata ke kode program yang kita buat
- Tidak semua orang membutuhkan Annotation, biasanya Annotation digunakan saat kita ingin membuat library / framework
- Annotation sendiri bisa diakses menggunakan Reflection, yang akan kita bahas nanti
- Untuk membuat class annotation, kita bisa menggunakan kata kunci annotation sebelum membuat class tersebut
- Annotation hanya boleh memiliki properties via primary constructor, tidak boleh memiliki members lainnya (function atau properties di body)

        Attribute Annotation :
        Attribute | Keterangan
        - @Target
          Memberitahu annotation bisa digunakan di mana? Class, function, properties, dan lain-lain
        - @Retention
          Memberitahu annotation apakah disimpan di hasil kompilasi, dan apakah bisa dibaca oleh reflection?
        - @Repeatable
          Memberitahu annotation apakah bisa digunakan lebih dari sekali di target yang sama?
        - @MustBeDocumented
          Memberitahu annotation apakah perlu didokumentasikan di public API

ANNOTATION  TARGET :

- Kotlin Annotation berjalan baik dengan Java Annotation
- Namun kadang kita ingin menempatkan posisi annotation sesuai dengan yang kita mau agar bisa terbaca di Java dengan baik
- Biasanya kejadian ini terjadi ketika kita menggunakan Kotlin, namun menggunakan framework Java, sehingga target lokasi Annotation nya harus sesuai dengan yang biasa digunakan framework tersebut di Java
- Di kotlin kita bisa menggunakan @target:NamaAnnotation nya untuk menentukan lokasi target Annotation akan ditempatkan dimana

REFLECTION :

- Reflection adalah kemampuan melihat struktur aplikasi kita pada saat berjalan
- Reflection biasanya sangat berguna saat kita ingin membuat library ataupun framework, sehingga bisa meng-otomatisasi pekerjaan
- Untuk mengakses reflection class dari sebuah object, kita bisa menggunakan kata kunci ::class, atau bisa langsung dari NamaClass::class

SCOPE FUNCTION :

- Kotlin memiliki standar library yang berisikan beberapa function yang bisa digunakan untuk mengeksekusi object dengan mudah memanfaatkan lambda expression
- Function-function tersebut adalah let, run, with, apply, dan also

        Let Function :
        - Let function bisa digunakan sebagai reference block agar kita bisa lebih mudah ketika ingin memanipulasi sebuah object
        - Let function memiliki parameter object itu sendiri, sehingga kita bisa menggunakan kata kunci it untuk mendapatkan referensi terhadap object tersebut

        Run Function :
        - Run function mirip dengan let function
        - Yang membedakan adalah, pada run function, tidak ada parameter pada lambda nya, sehingga kita tidak bisa mengakses reference object menggunakan kata kunci it. Namun kita masih bisa menggunakan kata kunci this

        Apply Function :
        - Apply function hampir sama dengan run function
        - Yang membedakan adalah return value dari apply function ada reference object itu sendiri

        Also Function :
        - Also function mirip dengan let function
        - Yang membedakan adalah, pada also function, return value nya adalah reference ke object itu sendiri

        With Function :
        - With function mirip dengan run function, menggunakan reference this
        - Yang membedakan adalah, with function bukanlah extension function, jadi tidak bisa digunakan langsung dari object-nya
        - Kita harus memanggil with function secara manual

        Kesimpulan (PR - Gambar)

POLYMORPHISM :

- Polymorphism berasal dari bahasa Yunani yang berarti banyak bentuk.
- Dalam OOP, Polymorphism adalah kemampuan sebuah object berubah bentuk menjadi bentuk lain
- Polymorphism erat hubungannya dengan Inheritance




